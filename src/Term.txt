클래스
클래스(Class)
클래스란 어떤 특정 종류의 모든 객체들에 대해 일반적으로 적용할 수 있는 변수와 메소드를 정의하고 있는 소프트웨어적인 설계도(blueprint) 또는 프로토타입(prototype)입니다.
@@
추상클래스
추상클래스
추상 클래스는 객체가 가지는 특성들을 추상화시켜 놓았을 뿐 아직 구체화 시키지 못한 클래스이므로, 이 추상클래스를 상속하는 하위 클래스에서 좀 더 구체화 시키도록 하는 것이다. 
따라서, 추상클래스를 상위 클래스로 하여 상속하는 하위 클래스는 추상클래스인 상위 클래스에서 완전히 구현하지 못한 부분들을 완전하게 구현해 주어야만 하위 클래스에 대한 객체 생성이 가능하고, 
그렇지 못할 경우 하위 클래스는 상위 클래스인 추상 클래스와 같이 미완성이므로 자체적으로 객체를 생성할 수 없고, 이 하위 클래스는 다시 추상 클래스가 된다.
추상 메소드의 특징
추상메소드는 추상클래스와 마찬가지로 아직 구현이 이루어지지 않고 단지 그 프로토입만 가지고 있는 메소드이다.
1. 추상메소드는 미완성 메소드이어야 하므로, 메소드의 몸체(body)를 가질수 없다.
2. 추상메소드는 클래스가 가져야 할 인터페이스에 대한 프로토타입(메소드의 형태)을 정의하고 있다.
3. 추상메소드는 하위클래스가 가져야 할 인터페이스를 정의한다.
4. 추상메소드를 포함하는 클래스는 반드시 추상클래스로 선언되어야 한다.
* 추상클래스(메소드) 선언 시 주의사항
  1. abstract 메소드를 하나라도 가지고 있다면 그 클래스는 반드시 abstract 클래스로 선언되어야 한다.
  2. abstract 클래스는 직접 객체를 생성할 수 없다.
  3. abstract 클래스를 사용하기 위해서는 이 클래스를 상속한 클래스에서 abstract 메소드를 구현해 주어야만 한다.
  4. 만약 abstract 클래스를 상속했는 데 abstract 메소드를 구현해 주지 않았다면 이 클래스 역시 abstract 클래스로 선언되어야 한다.
  5. abstact 한 메소드가 없어도 abstract class로 선언할 수 있다.( 상속을 통해서만 접근 가능)
@@
상속
상속(Inheritance)
객체지향 개념은 클래스를 이용하여 다른 클래스를 생성 또는 정의할 수 있다. 다시 말해서, 하위클래스는 상위클래스가 갖고 있는 모든 특성들을 상속하여 사용할 수 있다. 
이러한 상속 관계를 트리로 나타낼 수 있고, 이 상속관계 트리를 클래스 계층도(class hierarchy)라 한다. 
상위클래스는 하위클래스들이 가질 수 있는 일반적인 상태와 행동을 정의하고 있고, 하위클래스는 하위클래스 만이 갖는 특별한 상태와 행동을 정의하도록 함으로써 상위클래스를 여러 하위클래스들이 재사용할 수 있고 소프트웨어 개발에 드는 비용을 감소할 수 있다. 
프로그램 개발자는 상위클래스를 일반적인 행동(genericbehavior)을 정의하도록 할 수 있고, 이러한 클래스를 추상 클래스(abstract class)라 한다. 
이러한 추상 클래스는 부분적으로 구현되거나 구현이나 정의가 이루어지지 않을 수 있는데, 이는 하위클래스를 정의하면서 완성할 수 있도록 가이드라인을 제공해 주는 역할을 한다.
@@
인터페이스
인터페이스
추상메소드와 파이널 변수로만 이루어진 클래스. 
따라서, 인터페이스 내에 정의된 메소드는 자바에 의해 자동으로 ‘public abstract’로 변수는 자동으로 ‘public static final’로 선언된다. 
구현이 이루어지지 않은 추상메소드를 포함하고 있는 인터페이스는 객체 생성을 할 수 없다. 
클래스가 인터페이스를 구현해주어야 상속이 가능하다. 이 때, 클래스는 인터페이스의 모든 메소드 및 변수들을 상속하게 되며, 인터페이스에 정의되어 있는 모든 메소드를 구현해 주지 않을 경우 이 클래스는 추상메소드를 포함하고 있으므로 추상클래스로 선언되어야 한다.
다음은 인터페이스의 일반적인 형태이다.
접근지정자 interface 인터페이스이름 [extends 상위인터페이스] {
   상수선언;
   메소드선언;
}
인터페이스의 용도
1. 강제적인 클래스 관계를 만들지 않으면서 서로 관련없는 클래스들 상이의 유사성을 나타내야 할 경우
2. 하나 이상의 클래스들이 구현하기를 원하는 메소드를 선언할 경우
3. 클래스를 보여주지 않고서 객체의 프로그래밍 인터페이스를 보여주어야 할 경우
인터페이스와 다중상속의 차이
자바에서 인터페이스가 다중 상속을 할 수 있도록 해준다고 하는데, 인터페이스는 다중 상속을 할 수 있도록 해 주는 것이 아니라 다중 상속을 하는 것처럼 해 주는 것이다.
1. 클래스는 인터페이스로부터 단지 상수만을 상속한다.
2. 클래스는 인터페이스로부터 메소드의 구현(몸체)에 대해서는 상속할 수 없다.
3. 인터페이스의 계층 구조는 클래스의 계층 구조와 서로 무관하다.
 	같은 인터페이스를 구현하는 클래스들은 클래스 계층 구조 상에서 서로 관련이 있을 수도 없을 수도 있다. 
	이러한 특성 때문에 진정한 다중 상속이라 할 수 없다. 그러나 자바에서는 하나의 인터페이스가 여러 개의 상위인터페이스를 가질 수 있도록 함으로써, 다중 인터페이스 상속을 할 수 있도록 해 준다.
인터페이스의 구현
클래스가 이 인터페이스를 상속(implements)하여 인터페이스에 정의된 모든 메소드를 구현해 주어야 객체생성이 가능하다. 
그리고, 클래스의 상속에서 하나의 클래스는 하나의 클래스만을 직속으로 상속할 수 있는 것과는 달리, 하나의 클래스는 여러 개의 인터페이스를 구현해 줄 수 있다.
인터페이스도 클래스와 마찬가지로 인터페이스를 상속할 수 있다. 그러나, 클래스 상속과 한 가지 차이점은 클래스는 오직 하나의 클래스만 상속 가능한테 비해, 인터페이스는 여러 개의 인터페이스를 상속할 수 있다. 
인터페이스가 상속하는 상위인터페이스들은 ‘,’로 구분하고, 상위인터페이스가 가지는 모든 상수와 메소드들을 상속하게 된다.
다음은 인터페이스 구현의 일반적인 형태이다.
접근지정자 class [extends 클래스이름]  implements 상위인터페이스리스트 {
   // 인터페이스에 선언된 메소드 구현
}
@@
커넥션풀
커넥션풀
데이터베이스와 연결된 커넥션을 미리 만들어서 풀(pool)속에 저장해 두고 있다가 필요 할때에 커넥션을 풀에서 가져다 쓰고 다시 풀에 반환하는 기법을 의미.
동시 접속자가 사용하는곳에 많이 사용하는 기법.
@@
오버로딩
오버로딩(Overloading)
하나의 이름으로 여러 개의 메서드를 가지고 있다.
같은 이름을 가진 여러 개의 메서드를 말합니다. 보통 다중정의, 중복 메서드라고 부르며 일반적으로는 Overloading이라고 합니다. 
이것은 하나의 이름으로 여러 개의 메서드를 가지고 있다는 뜻을 내포하고 있다.

Overloading Method의 규칙
1.매개변수의 개수가 달라야 한다.
2.매개변수의 타입이 달라야 한다.
3.위의 개수와 타입 중 하나만 달라도 중복메서드의 조건이 성립 됩니다.
4.메서드의 리턴타입은 중복메서드 구분할 때 사용하지 않습니다.
@@
오버라이딩
오버라이딩(Overriding)
상속관계에서 상위 클래스와 하위 클래스에 동일한 이름의 메서드가 있는 것을 보고 이야기 하는 것
@@
인스턴스
인스턴스(Instance)
클래스를 실제로 사용할 수 있도록 선언하는 것, 다시 말해서 클래스에 대한 변수를 선언하는 것을 “인스턴스를 생성한다(instantiate)”라 하고, 이렇게 생성된 변수를 인스턴스라 하며, 이 인스턴스는 메모리 공간을 차지하게 된다.
그리고 인스턴스의 메소드를 이용하여 변수들의 값을 설정 및 변경할 수 있다.  
@@
객체
객체(Object)
클래스를 실제 사용할 수 있도록 변수 선언한 것을 인스턴스이며, 이 인스턴스를 객체라 할 수 있다. 객체는 높은 모듈성(modularity)과 정보은닉(information hiding)의 장점을 제공.
@@
다형성
다형성(Polymorphism)
다형성의 기본 개념은 여러 개의 클래스가 같은 메시지에 대해서 각자의 방법으로 작용할 수 있는 능력이라고 볼 수 있다.
다형성은 같은 이름을 갖는 여러 가지 형태가 존재한다. 다형성을 제공해 주기 위해 C++에서는 연산자 다중 정의(overloading), 함수 다중 정의, 그리고 함수 재정의(overriding) 등을 제공해 주고 있지만, 
자바에서는 메소드(함수) 다중 정의와 메소드 재정의를 제공해 주고 있다.
@@
스태틱
스태틱(static)
1.클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통적으로 사용해야하는 것에 static을 붙인다.
	인스턴스를 생성하면, 각 인스턴스들은 서로 독립적기 때문에 서로 다른 값을 유지한다.
    	경우에 따라서는 각 인스턴스들이 공통적으로 같은 값이 유지되어야 하는 경우 static을붙인다.
2. static이 붙은 멤버변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
	static이 붙은 멤버변수(클래스변수)는 클래스가 메모리에 올라갈때 이미 자동적으로
	생성되기 때문이다.
3. static이 붙은 메서드(함수)에서는 인스턴스 변수를 사용할 수 없다.
	static이 메서드는 인스턴스 생성 없이 호출가능한 반면, 인스턴스 변수는 인스턴스를 생성해야만 존재하기 때문에 static이 붙은 메서드(클래스메서드)를 호출할 때
   	 인스턴스가 생성되어있을수도 그렇지 않을 수도 있어서 static이 붙은 메서드에서 인스턴스변수의 사용을 허용하지 않는다.
	(반대로, 인스턴스변수나 인스턴스메서드에서는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스변수가 존재한다는 것은 static이 붙은 변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.)
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
	메서드의 작업내용중에서 인스턴스 변수를 필요로 한다면, static을 붙일 수 없다.
	반대로 인스턴스변수를 필요로 하지 않는다면, 가능하면 static을 붙이는 것이 좋다.
	메서드 호출시간이 짧아지기 때문에 효율이 높아진다.
	(static을 안붙인 메서드는 실행시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다.)
5. 클래스 설계시 static의 사용지침
	먼저 클래스의 멤버변수중 모든 인스턴스에 공통된 값을 유지해야하는 것이 있는지 살펴보고 있으면, static을 붙여준다.
	작성한 메서드 중에서 인스턴스 변수를 사용하지 않는 메서드에 대해서 static을 붙일 것을 고려한다.
 	일반적으로 인스턴스변수와 관련된 작업을 하는 메서드는 인스턴스메서드(static이 안붙은 메서드)이고 static변수(클래스변수)와 관련된 작업을 하는 메서드는 클래스메서드(static이 붙은 메서드)라고 보면 된다.
Container
 	객체의 저장 이라는 관점에서 우리가 흔히 생각하는 것은 배열(array)이다. 특히나 원시(primitive)타입의 값들을 저장하여 다룰때 배열을 많이 사용한다.
	배열로 코드를 작성시 우리가 필요로 하는 객체들이 얼마나 되는지, 또는 객체 저장을 위해 더 복잡한 방법이 필요한지 알 수 없다. 
	따라서 "크기가 한번 정해지면 바꿀 수 없다" 라고 하는 것은 배열의 가장 큰 단점이며, 그로인한 제약은 상당히 크다.
	이러한 문제의 해결 방안으로 java.util 라이브러리에는 컨테이너(container) 클래스 들이 있으며, 그것의 기본 타입들은 List, Set, Queue, Map 이다.
@@
EJB
EJB(Enterprise JavaBeans)
	분산 컴포넌트와 DB에 대한 접근 방법을 제공하는 기술이라고 할 수 있다. 복잡한 구조와 많은 코드, 복잡한 XML 정의가 필요하다.
@@
POJO
POJO(Plain Old Java Object)
	오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어이다. 
	2000년 9월에 마틴 파울러, 레베카 파슨, 조쉬 맥킨지 등이 사용하기 시작한 용어로서 마틴 파울러는 다음과 같이 그 기원을 밝히고 있다. 
		"우리는 사람들이 자기네 시스템에 보통의 객체를 사용하는 것을 왜 그렇게 반대하는지 궁금하였는데, 간단한 객체는 폼 나는 명칭이 없기 때문에 그랬던 것이라고 결론지었다. 그래서 적당한 이름을 하나 만들어 붙였더니, 아 글쎄, 다들 좋아하더라고.	”
		 — 마틴 파울러
@@
역제어
역제어 IoC(Inversion of Control) 
 	프로그래머가 작성한 프로그램이 재사용 라이브러리의 흐름 제어를 받게 되는 소프트웨어 디자인 패턴을 말한다.
	일반적인 프로그래밍에서 흐름은 프로그래머가 작성한 프로그램이 외부 라이브러리의 코드를 호출해 이용한다.
	하지만 제어 반전이 적용된 구조에서는 외부 라이브러리의 코드가 프로그래머가 작성한 코드를 호출한다.
	설계 목적상 제어 반전의 목적
		작업을 구현하는 방식과 작업 수행 자체를 분리한다.
		모듈을 제작할 때, 모듈과 외부 프로그램의 결합에 대해 고민할 필요 없이 모듈의 목적에 집중할 수 있다.
		다른 시스템이 어떻게 동작할지에 대해 고민할 필요 없이, 미리 정해진 협약대로만 동작하게 하면 된다.
		모듈을 바꾸어도 다른 시스템에 부작용을 일으키지 않는다.
@@
SOA
SOA(Service-oriented architecture)
 	대규모 컴퓨터 시스템을 구축할 때의 개념으로 업무상의 일 처리에 해당하는 소프트웨어 기능을 서비스로 판단하여 그 서비스를 네트워크상에 연동하여 시스템 전체를 구축해 나가는 방법론이다.
@@
느슨한 연결
느슨한 연결(Loose coupled)
	코딩의 한 부분이 다른 부분에 지나치게 의존적이 되도록 코딩하지 말라는 것입니다. 
	또 달리 말하면 반드시 특정 클래스 객체만 다루도록 코드를 만들지 말라는 것입니다. 
	전역변수를 많이 사용하지 말라는 것도 이 개념에 포함된다 할수 있습니다. 
	전역변수에 의존하면 서로 의존적인 코드가 많아져서 어떤 부분을 바꿀 때 여러 부분을 동시에 수정해야 하는 상황이 발생하기 때문입니다.
@@
SOAP
SOAP(simple object access protocol)
	일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. 
	SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다. 
	SOAP에는 몇가지 형태의 메시지 패턴이 있지만, 보통의 경우 원격 프로시져 호출(Remote Procedure Call:RPC) 패턴으로 네트워크 노드(클라이언트)에서 다른 쪽 노드(서버)로 메시지를 요청 하고 서버는 메시지를 즉시 응답하게 된다. 
	SOAP는 XML-RPC와 WDDX에서 envelope/header/body로 이루어진 구조와 전송(transport)과 상호 중립성(interaction neutrality)의 개념을 가져왔다.
@@
WSDL
WSDL(Web services description language)
	웹 서비스 기술언어 또는 기술된 정의 파일의 총칭으로 XML로 기술된다. 
	웹 서비스의 구체적 내용이 기술되어 있어 서비스 제공 장소, 서비스 메시지 포맷, 프로토콜 등이 기술된다.
@@
컴포넌트
Component
	유저가 사용하는 시스템에 대한 조작장치를 말한다. 통상 컨트롤(Control)이라고도 하고 UI라고도 한다.
	독립적인 기능을 수행하고 추후에 교환될 수 있도록 해야한다.
	또한 컴포넌트의 세부사항은 겉으로 드러나선 안되는것 이며, 일부러 끄집어 내려는 시도조차 하지 말아야 한다.
	필요한것은 단지 해당 컴포넌트를 쓰기 위해 제공해주는 일종의 장치가 필요하다.
@@
DAO
DAO(Data Access Object)
	실질적으로 DB에 접근하는 객체를 말한다.
	DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.
	DAO의 사용 이유는 효율적이 커넥션 관리와 보안성 때문이다.
@@
DTO
DTO(Data Transfer Object)
	Controller, View, Business Layer, Persistent Layer 등의 각 계층간 데이터 교환을 위한 객체를 의미합니다.
	DTO는 로직을 가지지 않는 순수한 데이터 객체이고 getter, setter 메소드만 가진 클래스를 의미합니다. 
@@
VO
VO(Value Object)
	DTO와 동일한 개념이나 차이점은 Read–Only 속성 객체이다.
	DTO와 VO의 공통점은 넣어진 데이터를 getter를 통해 사용하므로 주 목적은 같습니다. 그러나 DTO의 경우는 가변의 성격을 가진 클래스 입니다(setter 활용). 그에반해 VO는 불변의 성격을 가졌기에 차이점이 있습니다. 
@@
CBD
CBD(Component Based Development)
	기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 만드는 소프트웨어 개발방법론이다. 
	기업들은 쇼핑바구니, 사용자 인증, 검색엔진, 카탈로그 등 상업적으로 이용 가능한 컴포넌트를 결합하여 그들의 전자상거래 응용 프로그램을 개발하는 컴포넌트 기반 개발을 사용한다.
@@
ORM
ORM(Object-Relational Mapping)
	데이터베이스와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환하는 프로그래밍 기법이다.
	객체 지향 언어에서 사용할 수 있는 "가상" 객체 데이터베이스를 구축하는 방법이다. 객체 관계 매핑을 가능하게 하는 상용 또는 무료 소프트웨어 패키지들이 있고, 경우에 따라서는 독자적으로 개발하기도한다.
@@
영속성
Persistence
	프로세스가 생성했지만 별개로 유지되는 상태의 특징 중 한 가지이며, 별도의 기억 장치에 데이터를 보존하는 것을 목적으로 한다. 
	이 특징으로 인해 프로그래머는 저장 장치로부터 데이터를 전송하는 작업 및 자료 구조 등을 이용해 데이터를 보존하는 것이 가능하다.
@@
CRUD
CRUD(Create,Read,Update,Delete)
	대부분의 컴퓨터 소프트웨어가 가지는 기본적인 데이터 처리 기능인 Create(생성), Read(읽기), Update(갱신), Delete(삭제)를 묶어서 일컫는 말이다. 
	이러한 4개의 조작을 모두 할 수 없다면 그 소프트웨어는 완전하다고 할 수 없다. 이들 기능은 매우 기본적이기 때문에, 한 묶음으로 설명되는 경우가 많다.
	사용자 인터페이스가 갖추어야 할 기능(정보의 참조/검색/갱신)을 가리키는 용어로서도 사용된다.
	유사 용어
		ABCD: add(추가), browse(보기), change(변경), delete(삭제)
		ACID: add(추가), change(변경), inquire(질의), delete(삭제)
		BREAD: browse(보기), read(읽기), edit(편집), add(추가), delete(삭제)
		VADE(R): view(참조), add(추가), delete(삭제), edit(편집), 트랜잭션 처리에서는 restore(복원) 추가
@@
MVC
MVC(model–view–controller)
	 소프트웨어 공학에서 사용되는 소프트웨어 디자인 패턴이다.
	이 패턴을 성공적으로 사용하면, 사용자 인터페이스로부터 비즈니스 로직을 분리하여 애플리케이션의 시각적 요소나 그 이면에서 실행되는 비즈니스 로직을 서로 영향 없이 쉽게 고칠 수 있는 애플리케이션을 만들 수 있다.
	MVC에서 모델은 애플리케이션의 정보(데이터)를 나타내며, 뷰는 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타내고, 컨트롤러는 데이터와 비즈니스 로직 사이의 상호동작을 관리한다.
@@
콜백
Callback
	다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다.
	일반적으로 콜백수신 코드로 콜백 코드(함수)를 전달할 때는 콜백 함수의 포인터 (핸들), 서브루틴 또는 람다함수의 형태로 넘겨준다.
@@
데이터소스
Datasource
	서버로부터 데이터베이스에 대해 연결을 구축하기 위해 사용하는 이름이다. 이 이름은 데이터베이스에 쿼리를 만들 때 공통적으로 사용된다. 데이터 소스 네임(DSN)은 데이터베이스에 대해 파일명과 동일할 필요는 없다.
@@
